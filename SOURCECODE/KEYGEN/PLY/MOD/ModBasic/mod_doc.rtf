{\rtf1\ansi\deff0{\fonttbl{\f0\fmodern\fprq1\fcharset0 Courier New;}}
\viewkind4\uc1\pard\lang1031\f0\fs20\par
\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\par
\par
 \'a6 MOD Player Tutorial by FireLight \'a6 Copyright (c) Brett Paterson 1994-95 \'a6\par
\tab\tab\tab    \'a6 Last updated 16/6/95 \'a6\par
\par
\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\'a6\par
\par
\par
+----------------------------------------------------------------------------+\par
\'a6                           \'a6\'a6\'a6 : SECTION 0: \'a6\'a6\'a6                             \'a6\par
\'a6                           \'a6\'a6\'a6     Index    \'a6\'a6\'a6                             \'a6\par
+----------------------------------------------------------------------------+\par
\par
Section 1 : INTRODUCTION\par
\tab\tab 1.1 Notes\par
\tab\tab 1.2 Terminology\par
\tab\tab 1.3 Contacting FireLight and feedback\par
\tab\tab 1.4 Future versions\par
Section 2 : THE LOADER\par
\tab\tab 2.1 Notes\par
\tab\tab 2.2 Verification\par
\tab\tab 2.3 Load Module Name\par
\tab\tab 2.4 Load Sample Information\par
\tab\tab 2.5 Load Order Information\par
\tab\tab 2.6 Load Pattern Data\par
\tab\tab       2.6.1 Four bytes?\par
\tab\tab 2.7 Load Sample Data\par
\tab\tab 2.8 Phew :)\par
Section 3 : PLAYING THE MOD\par
\tab\tab 3.1 Ok Where Do I Start?\par
\tab\tab 3.2 Setting The Timer's Speed\par
\tab\tab 3.3 Player Logic\par
\tab\tab       3.3.1   Orders/Patterns\par
\tab\tab 3.4 Inside Update Row\par
\tab\tab 3.5 Period Frequencies and Fine Tune\par
\tab\tab       3.5.1   What do I do with this table?\par
\tab\tab       3.5.2   Gravis UltraSound :)\par
\tab\tab 3.6 Volume\par
Section 4 : MISCELLANEOUS\par
\tab\tab 4.1 Notes Without Instrument Numbers or Frequencies\par
Section 5 : EFFECTS\par
\tab\tab 5.1 Effect 0xy (Arpeggio)\par
\tab\tab 5.2 Effect 1xy (Porta Up)\par
\tab\tab 5.3 Effect 2xy (Porta Down)\par
\tab\tab 5.4 Effect 3xy (Porta To Note)\par
\tab\tab 5.5 Effect 4xy (Vibrato)\par
\tab\tab 5.6 Effect 5xy (Porta + Vol Slide)\par
\tab\tab 5.7 Effect 6xy (Vibrato + Vol Slide)\par
\tab\tab 5.8 Effect 7xy (Tremolo)\par
\tab\tab 5.9 Effect 8xy (Pan)\par
\tab\tab 5.10 Effect 9xy (Sample Offset)\par
\tab\tab 5.11 Effect Axy (Volume Slide)\par
\tab\tab 5.12 Effect Bxy (Jump To Pattern)\par
\tab\tab 5.13 Effect Cxy (Set Volume)\par
\tab\tab 5.14 Effect Dxy (Pattern Break)\par
\tab\tab 5.15 Effect Fxy (Set Speed)\par
\tab\tab 5.16 Effect E0x (Set Filter)\par
\tab\tab 5.17 Effect E1x (Fine Porta Up)\par
\tab\tab 5.18 Effect E2x (Fine Porta Down)\par
\tab\tab 5.19 Effect E3x (Glissando Control)\par
\tab\tab 5.20 Effect E4x (Set Vibrato Waveform)\par
\tab\tab 5.21 Effect E5x (Set Finetune)\par
\tab\tab 5.22 Effect E6x (Pattern Loop)\par
\tab\tab 5.23 Effect E7x (Set Tremolo WaveForm)\par
\tab\tab 5.24 Effect E8x (Unused)\par
\tab\tab 5.25 Effect E9x (Retrig Note)\par
\tab\tab 5.26 Effect EAx (Fine Volume Slide Up)\par
\tab\tab 5.27 Effect EBx (Fine Volume Slide Down)\par
\tab\tab 5.28 Effect ECx (Cut Note)\par
\tab\tab 5.29 Effect EDx (Delay Note)\par
\tab\tab 5.30 Effect EEx (Pattern Delay)\par
\tab\tab 5.31 Effect EFx (Invert Loop)\par
\par
Section 6 : APPENDIX - MOD FORMAT DOCUMENT\par
\par
+----------------------------------------------------------------------------+\par
\'a6                           \'a6\'a6\'a6 : SECTION 1: \'a6\'a6\'a6                             \'a6\par
\'a6                           \'a6\'a6\'a6 Introduction \'a6\'a6\'a6                             \'a6\par
+----------------------------------------------------------------------------+\par
\par
+-------------------+\par
\'a6 \'a6\'a6\'a6 1.1 Notes \'a6\'a6\'a6 \'a6\par
+-------------------+\par
\par
New in this version: \par
- Loader mistake fixed in section 2.6 ->\par
\tab   - store SAMPLE_NUMBER as    (byte1 AND 0F0h) + (byte2 SHR 4)\par
\tab   should have been                 ^\par
\tab   - store SAMPLE_NUMBER as    (byte0 AND 0F0h) + (byte2 SHR 4)\par
\tab\tab\tab\tab\tab    ^\par
- Section 3.4, Inside Update row rewritten, the old one was weird and crap\par
- Pattern break and pattern jump more accurately described\par
- New section 2.6.1 - Four bytes?\par
- Section 3.5.1 rewritten.\par
\par
Preamble:\par
=========\par
I am covering the .MOD format here basically because it's not a very good\par
idea to try and leap into a harder format like xm or s3m without prior\par
knowledge.  MOD still *IS* the most widely spread format so there's nothing\par
wrong with coding a player for it.  S3M is the next step up because it is\par
basically just a wider .MOD with more octaves and a volume byte.  (blah yeah\par
I know there are 99 samples and more effects, that's just cosmetic though.)\par
(ie s3m still use the same crap amiga frequencies as mod - for a PC format!).\par
\par
Assumptions:\par
============\par
Throughout the document, exaggerated length variable names are used, I don't\par
actually use these sort of variable names but they help to make things \par
clearer. eg "NUMBER_OF_PATTERNS".  Variable names will be all stated in \par
capitals.\par
\par
It is assumed you will have some sort of knowledge about\par
\tab - Sound Cards (and programming of sound cards, though I do include\par
\tab\tab\tab gus code in fmoda.asm)\par
\tab - Interrupt Handlers (I will cover this a bit though)\par
\par
Most of the time I present a type of pseudocode to try not to seem to biased\par
towards a language, but some examples I have used straight C code only to\par
demonstrate how I did it.  C should be fairly intuitive to read so most\par
people wont have that hard a time figuring it out.\par
\par
+-------------------------+\par
\'a6 \'a6\'a6\'a6 1.2 Terminology \'a6\'a6\'a6 \'a6\par
+-------------------------+\par
     \par
     TYPE    LENGTH  Bits    RANGE                   BORLAND/TURBO C\par
     --------------------------------------------------------------------\par
     byte    1       8       0-255                   unsigned char\par
     word    2       16      0-65,535                unsigned int\par
     dword   4       32      0-4,294,967,295         unsigned long\par
     --------------------------------------------------------------------\par
Throughout this text I use the terms BYTE,WORD, and DWORD, to make the\par
document more general to all languages.  In C you can use typedefs to achieve\par
the use of byte,word,dword terminology, and in pascal and asm the syntax is\par
already suited to this anyway.\par
\par
ORDERS   - orders are how the mod plays from 0 to length of song.\par
PATTERNS - patterns are played in any ORDER, and are the physical information.\par
\par
TICK - I refer to a clock tick for the interrupt handler as a tick, some\par
others use the term FRAME.  I will be using the term tick throughout the whole\par
document.\par
\par
+-----------------------------------------------+\par
\'a6 \'a6\'a6\'a6 1.3 Contacting FireLight and feedback \'a6\'a6\'a6 \'a6\par
+-----------------------------------------------+\par
\par
Contact is encouraged because I think I have left out some things and \par
probably made some mistakes (not that I can see), and would like you to\par
tell me about them.\par
\par
email : firelght@yoyo.cc.monash.edu.au \par
 post : Brett Paterson,                \par
\tab 48/a Parr st,\par
\tab Leongatha, 3953,\par
\tab Victoria, Australia.\par
phone : AU (056) 623795                \par
  IRC : FireLight on #coders, #trax or #aussies\par
\par
+-----------------------------+\par
\'a6 \'a6\'a6\'a6 1.4 Future versions \'a6\'a6\'a6 \'a6\par
+-----------------------------+\par
Im really starting to get into this stuff, so here is what will appear in\par
future versions of this document.\par
\par
o Mixing techniques - This is a very important section and I really want this\par
\tab\tab     to be included in here but need an experienced SB mod\par
\tab\tab     coder to write this section for me (anyone out there!!!)\par
o How to handle multiple formats - talking about your internal format for\par
\tab\tab     handling multiple formats.  I am currently updating fmod\par
\tab\tab     to support s3m and mtm and so info on these formats will\par
\tab\tab     be included.\par
\par
+----------------------------------------------------------------------------+\par
\'a6                           \'a6\'a6\'a6 : SECTION 2 : \'a6\'a6\'a6                            \'a6\par
\'a6                           \'a6\'a6\'a6  The Loader   \'a6\'a6\'a6                            \'a6\par
+----------------------------------------------------------------------------+\par
\par
+-------------------+\par
\'a6 \'a6\'a6\'a6 2.1 Notes \'a6\'a6\'a6 \'a6\par
+-------------------+\par
Well first we've got to load the module in right?  Following is a step by\par
step way to code your loader, and storage issues will be discussed to help\par
you along.  I really don't feel like just writing another MOD format\par
description, so you will find one in the appendix of section 6 written by\par
lars hamre(?), the author of protracker.\par
\par
You WILL need to refer to the format document and this document side by side.\par
The loader section of this document doesnt actually give a map of mod format\par
and could be confusing, though it does go through it byte by byte.\par
\par
The following section has their subsections which are in boxes, and in each\par
of these sections are 3 important subsections\par
\par
- EXPLANATION   (describes what the section is on about, for understanding)\par
- PSEUDOCODE    (actually shows HOW to load the information)\par
- STORAGE ISSUE (helps on how to store the information loaded)\par
- SUGGESTION    (a helpfull hint or suggestion to do after this step)\par
\par
I placed the pseudocode section before storage issues because I know you are\par
probably going to be eager and want to jump into some code straight away.\par
Storage issue follows just to be a guiding hand; not a 'must'.\par
each pseudocode section follows on from the last.\par
\par
+--------------------------+\par
\'a6 \'a6\'a6\'a6 2.2 Verification \'a6\'a6\'a6 \'a6\par
+--------------------------+\par
\par
Explanation:\par
============\par
Before we attempt to load a mod, we should check that it is in fact a mod.\par
Every mod has a unique signature, and in case of the .MOD format, this is \par
in the form of a 4 letter string containing the letters "M.K.", or "8CHN" or\par
a variety of other signatures for their mutated formats :)\par
  These describe the type of mod, and the identifier signature is stored at\par
offset 1080 (438h) in the file, so should be checked first.\par
\par
\par
PseudoCode:\par
===========\par
- Seek to offset 1080 (438h) in the file\par
- read in 4 bytes\par
-           compare them to "M.K."  - if true we have a 4 channel mod\par
- otherwise compare them to "6CHN"  - if true we have a 6 channel mod\par
- otherwise compare them to "8CHN"  - if true we have an 8 channel mod\par
- otherwise exit and display error message.\par
\par
There are also rare tunes that use **CH where ** = 10-32 channels\par
\par
Suggestion:\par
===========\par
Use this point to store the number of channels in a variable of your choice\par
(I just use a global variable called CHANNELS)\par
\par
\par
+------------------------------+\par
\'a6 \'a6\'a6\'a6 2.3 Load Module Name \'a6\'a6\'a6 \'a6\par
+------------------------------+\par
\par
Explanation:\par
============\par
This is a trivial part of the loader and just holds the Title or name of the\par
mod.  It is the very first 20 bytes of the MOD.\par
\par
PsuedoCode:\par
===========\par
- Seek back to position 0, the start of the file\par
- read in 20 bytes, store as MODULE_NAME.\par
\par
Storage Issue:\par
==============\par
The name of the module is a 20 byte string, padded by 0's.\par
Here you can either store your module name as a global variable, in a\par
character string, or do what I do and store all the general information about\par
the mod in a structure like this\par
\par
struct MODHEADER \{\par
\tab char NAME[20]\par
\tab ...\par
\tab other information (will get to this later)\par
\tab ...\par
\} MODHEAD\par
\par
OR just\par
\par
char NAME[20]\par
\par
It's a good idea to set up a structure like this for future use, there is a\par
lot more infomration we will need to throw in here later, but of course you\par
don't need a structure, you can keep it as a heap of loose variables :)\par
And of course if you are not interested in displaying the name of the module\par
you could just discard it.\par
\par
Suggestion:\par
===========\par
Code a 1 line program to print out the name of your module to see if it's\par
working properly. (exciting huh :)\par
\par
NOTE: The Module name is supposed to be padded by 0's, and terminated with a\par
      0, but sometimes this is not the case.  Sometimes a tracker will allow\par
      all 20 bytes to store characters, which means no NULL termintor byte.\par
\tab This causes functions like printf to give unpredictable output as it \par
      cannot find the NULL terminator.  The way to fix this is just to use a \par
      loop and print out each character one at a time, or overwrite the 20th\par
      byte with a 0.\par
\par
+-------------------------------------+\par
\'a6 \'a6\'a6\'a6 2.4 Load Sample Information \'a6\'a6\'a6 \'a6\par
+-------------------------------------+\par
\par
Explanation:\par
============\par
Sample information is stored at the start of a MOD file, and contains all the\par
relevant information for each of the 31 samples.  This includes its name,\par
length, loop points, finetune etc..\par
So from here we loop 31 times and read in a block of information about the \par
sample according to the loop counter.\par
\par
PseudoCode:\par
===========\par
- from this point, loop 31 times\par
\tab - for the sample # <loopcounter>....\par
\tab - read in 22 bytes,       store as SAMPLE_NAME\par
\tab - read in 2 bytes (word), store as SAMPLE_LENGTH  *   \\\par
\tab - read in 1 byte,         store as FINE_TUNE      @   /\\ IMPORTANT:\par
\tab - read in 1 byte,         store as VOLUME               \} see key\par
\tab - read in 2 bytes (word), store as LOOP_START     *   \\/   below\par
\tab - read in 2 bytes (word), store as LOOP_LENGTH    *   /\par
- end of loop\par
\par
KEY:\par
* to get the real value in bytes, calculate it with (byte1*100h + byte2) * 2\par
@ for FINE_TUNE, if the value is > 7, subtract 16 from it to get the signed\par
   value (ie. 0-7 = 0-7, and 8-15 = -8 to -1)\par
\par
Storage Issue:\par
==============\par
I think the best way to store information on the 31 instruments, is to store\par
its information in a structure, then have an array of 31 of these intstrument\par
structures. Like this :\par
\par
struct SAMPLE \{\par
\tab char SAMPLE_NAME[22]\par
\tab word SAMPLE_LENGTH\par
\tab byte FINE_TUNE\par
\tab byte VOLUME\par
\tab word LOOP_START\par
\tab word LOOP_LENGTH\par
\par
\tab (also some physical position information - see sample loading section.\par
\tab  some possibilities are under GUS...\par
\par
\tab dword GUS_OFFSET\par
\par
\tab OR using main memory with sb say..\par
\tab\par
\tab char *SAMP_BUFF (pointer to the actual physical data in memory)\par
\}\par
\par
now declare an array of 31 SAMPLEs.  I do this in the general mod header \par
structure which is explained fully in the next section.\par
The other way which can be used is just to keep a heap of global arrays like\par
this;\par
\par
char SAMPLE_NAME[31][22]\par
word SAMPLE_LENGTH[31]\par
byte FINE_TUNE[31]\par
byte VOLUME[31]\par
word LOOP_START[31]\par
word LOOP_LENGTH[31]\par
\par
Suggestion:\par
===========\par
Now code a little viewer once you have done this to make sure everything is\par
stored properly.  This is VERY a important step.  Compare your output to\par
the tracker it came from or a player that shows all sample information.\par
\par
\par
+------------------------------------+\par
\'a6 \'a6\'a6\'a6 2.5 Load Order Information \'a6\'a6\'a6 \'a6\par
+------------------------------------+\par
\par
Explanation:\par
============\par
Ok now sample information is loaded, the next section of the module contains\par
order information.  Order information in a mod defines in what order patterns\par
are going to be played.  This means the composer could set orders 0 and 1 \par
to pattern 0, for example, and the intent would be for pattern 0 to play \par
twice.  Its entry in the order table would look like this.\par
\par
ORDER  : 0 1 2 3 4 5 6 7 8 9\par
PATTERN: 0 0 \par
\par
Note orders have to be from 0 to length of song, but patterns can be chopped\par
and changed around in any order.\par
The first byte from here will tell us the length of the song in -orders-,\par
even though they are stored in 128 bytes of information.\par
\par
PsuedoCode:\par
===========\par
- read a byte, store as SONG_LENGTH (this is the number of orders in a song)\par
- read a byte, discard it (this is the UNUSED byte - used to be used in PT as\par
   the restart position, but not now since jump to pattern was introduced)\par
\par
Now we are at the orders table, this is 128 bytes long and contains the order\par
of patterns that are to be played in the song.  here we have to find out how\par
many physical patterns there are in the module.  How do we do this? Simple\par
just check every order byte and the highest value found is stored as the\par
number of patterns in the song.\par
\par
- set NUMBER_OF_PATTERNS to equal 0\par
- from this point, loop 128 times\par
     - read 1 byte, store it as ORDER <loopcounter>\par
     - if this value was bigger than NUMBER_OF_PATTERNS then set it to that\par
       value.\par
- end of loop\par
- read 4 bytes, discard them (we are at position 1080 again, this is M.K. etc!)\par
\par
Storage Issue:\par
==============\par
One way is to go back to the other original MODhead structure, which contained\par
general infomation about the mod. here is the entire structure.\par
\par
struct MODHEADER \{\par
\tab char NAME[20]              ; song name\par
\tab SAMPLE INST[31]            ; instrument headers\par
\tab byte SONG_LENGTH           ; song length\par
\tab byte NUMBER_OF_PATTERNS    ; number of physical patterns\par
\tab byte ORDER[128]            ; pattern playing orders\par
\} MODHEAD;\par
\par
or the second way would just to be store them all as global variables\par
\par
char NAME[20]                      ; song name\par
byte SONG_LENGTH                   ; song length\par
byte NUMBER_OF_PATTERNS            ; number of physical patterns\par
byte ORDER[128]                    ; pattern playing orders\par
\par
no array of samples here because if you saw the sample header loading section\par
we just stored them all as their own arrays.\par
\par
Suggestion:\par
===========\par
As always print out the 128 orders, and see if the pattern numbers displayed\par
are correct.  Now you should have a viewer that can just about display every\par
bit of information about the module!  OK that stuff was easy.  Now it's time\par
for something tougher.. the pattern data!\par
\par
+-------------------------------+\par
\'a6 \'a6\'a6\'a6 2.6 Load Pattern Data \'a6\'a6\'a6 \'a6\par
+-------------------------------+\par
\par
Explanation:\par
============\par
\par
This is about the hardest part to code of the loader, and storage issues here \par
are VERY important, so it will be discussed first.  Im going to try and be as \par
general as I can as I don't want to appear to be trying to steer you in any \par
direction, but I will be specific enough to guide you.\par
\par
Storage Issues:\par
===============\par
There are only a few ways to store pattern data, Ive spent some time pondering\par
this issue.  I found the only viable methods of storing pattern data are -\par
\par
1- Linked List, using channels as nodes (dynamic but slow, well not THAT slow)\par
2- Fixed arrays (terribly memory wasting and messy)\par
3- Create and allocate a buffer the size we need to store all the patterns, \par
    and then use a roving pointer to access patterns later  (sounds ok to me)\par
\par
Patterns really need to be stored DYNAMICALLY, or in other words only use as\par
much memory as you need.\par
Method 1   Was the method I used to begin with, for the sole reason that it is\par
\tab    nicely dynamic and easy.  It was quite ok to start on and was good\par
\tab    enough for me (with GUS), but I scrapped that idea and went for\par
\tab    the final method.  Method 3 is much more general to all languages\par
\tab    too.\par
Method 2   Is out for this reason, it just isnt memory efficient enough.\par
\tab    And also you cant subscript arrays in a normal high level language\par
\tab    with indexes larger than 65536.  (method 3 is an extension of this)\par
Method 3.  This method is quite easy and efficent to use and very dynamic,\par
\tab    once you have worked out how to allocate and access huge pointers\par
\tab    which can be up to 640kb big :)  Players that seem to use this \par
\tab    method are GUSPlay by Cascada, and ProTracker by Lars Hamre.\par
\tab    FireMod 1.02 and higher, by myself uses this method.\par
\par
It works this way:\par
\par
- declare a pointer and allocate it the amount of memory calculated below;\par
\par
\tab   CHANNELS * 4 * 64 * (NUMBER_OF_PATTERNS+1)\par
\tab\tab      \'a6   \'a6\par
\tab\tab      \'a6   +--- (rows per channel)\par
\tab\tab      +------- (bytes per note)\par
\par
Why add 1 to NUMBER_OF_PATTERNS? well because patterns start at 0, and finish\par
at NUMBER_OF_PATTERNS, hence the aditional 1.  If you didnt add 1 and there\par
was only 1 pattern you would end up allocating 0 bytes for the pattern data :)\par
\par
This value is normally going to be a very big number, so a dword will be\par
needed to store it.  I initially had problems with data wrapping around at\par
64kb with my buffer using char far *, (say if it was 500kb large), but this\par
was fixed by delcaring it with the huge keyword (look up online help to find\par
out more) - eg : char huge *patbuff.\par
\par
So to find the physical pattern in your pattern buffer, calculate the offset\par
with the formula (channels * 4 * 64) * pattno.\par
Say we want to point to the start of pattern 4 in an 8CHN mod.\par
  (8 * 4 * 64) * 4\par
  = 8192.\par
So as you travel through this pattern just increment your pointer by 4 bytes\par
at a time.\par
\par
A note is stored in the actuall file as 4 bytes, it is done in this fashion.  \par
The pseudocode below shows how to unravel this amigafied mess :)\par
\par
+-------------------------------------+\par
\'a6 Byte 0    Byte 1   Byte 2   Byte 3  \'a6\par
\'a6-------------------------------------\'a6\par
\'a6aaaaBBBB CCCCCCCCC DDDDeeee FFFFFFFFF\'a6\par
+-------------------------------------+\par
aaaaDDDD     = sample number\par
BBBBCCCCCCCC = sample period value\par
eeee         = effect number\par
FFFFFFFF     = effect parameters\par
\par
PseudoCode:\par
===========\par
- calculate amount of memory needed for NUMBER_OF_PATTERNS patterns like so:\par
    CHANNELS * 4 * 64 * (NUMBER_OF_PATTERNS+1)\par
- create a base pointer and allocate the memory needed\par
- From this point, loop for as many times as NUMBER_OF_PATTERNS\par
     - From this point, loop 64 * CHANNELS times (this equals 1 pattern)\par
\tab   - read 4 bytes\par
\tab   - store SAMPLE_NUMBER as    (byte0 AND 0F0h) + (byte2 SHR 4)\par
\tab   - store PERIOD_FREQUENCY as ((byte0 AND 0Fh) SHL 8) + byte1;\par
\tab   - store EFFECT_NUMBER as    byte2 AND 0Fh\par
\tab   - store EFFECT_PARAMETER as byte 3\par
\tab   - increment pattern pointer by 4 bytes\par
     - end loop\par
- end loop\par
\par
OK:\par
===\par
Alright so lets look at this again in simpler terms:\par
 - We have a big buffer that is meant to store all the pattern data\par
 - Then we start loading in the notes *4* bytes at a time, and unravel them\par
     into something meaningful as shown above.\par
 - store the new note variables one after the other, and it should fill the\par
     buffer to the exact size as was allocated in the beginning.\par
\par
Suggestion:\par
===========\par
With EFFECT_PARAMTER, you might be tempted to store the 2 values stored in\par
here as 2 seperate variables, eg. EFFECT_PARAMETER_X, and EFFECT_PARAMETER_Y.\par
I used to store them this way but I assure you when you get into coding your\par
effects this this method is quite inefficient, I saved memory and increased\par
speed (but not noticably :) just by storing them in the 1 byte, and splitting\par
them only in the few times that you do need it. (i.e, printing them out\par
separately, or vibrato, or for finding out which E (extra) effect to use etc.)\par
\par
+---------------------------+\par
\'a6 \'a6\'a6\'a6 2.6.1 Four bytes? \'a6\'a6\'a6 \'a6 *IMPORTANT*\par
+---------------------------+\par
\par
At this stage you're probably thinking.. how do I fit all this into only 4\par
bytes?\par
For a start, DONT store the amiga periods as your note value.  Convert each\par
period to a note number.  **See section 3.5.1** for more discussion on notes\par
and frequencies.  In summary you just scan through the amiga table until it\par
matches the value you loaded in.\par
\par
Anyway even if you did store the amiga period value as your note (which you\par
wont), then you can still fit it all into 4 bytes.  The file did it so why\par
cant you.\par
I use bit allocation.  This means I only use the bits I need in a byte, and\par
not a whole byte.\par
\par
An example of this is the note volume is only capable of getting up to 64, so\par
we only need 6 bits.  The sample number goes up to 31.  This only needs 5\par
bits.  Follow here and see how things are allocated.  This is similar to the\par
way I do it in my player.  In C you can allocate a variable and tell how many\par
bits you want to use.  In asm i'd say you would have to use a 4 bytes, and do \par
the bit calculations yourself before you access them, which shouldnt be too \par
hard.\par
\par
int note:11;    // 0-??  = 11 bits = 0-2048 should be plenty for your needs.\par
byte number:5;  // 0-31  = 5 bits\par
byte effect;    // 0-15  = 4 bits, but use 8 to keep things even\par
byte eparm;     // 0-255 = 8 bits\par
\par
I actually use 3 bytes for my new player.  I first convert finetunes to a\par
middle C value in hz like s3m (see st3's tech.doc how this works), therefore \par
I only need the amiga table for the actual notes and not the finetunes \par
between.\par
So I get something like note=7bits, number=5bits, effect=4bits, eparm=8bits,\par
= 7+5+4+8 = 24 = 3bytes!\par
\par
+------------------------------+\par
\'a6 \'a6\'a6\'a6 2.7 Load Sample Data \'a6\'a6\'a6 \'a6\par
+------------------------------+\par
\par
PsuedoCode:\par
===========\par
- From this point, loop 31 times\par
     - get the length of the sample # <loopcounter> (stored in your variable)\par
\par
At this point I use only GUS, and dump the sample to the GUS dram, but I\par
could imagine if you were using Sound Blaster etc, you would just declare 31\par
pointers in memory and allocate them a SAMPLE_LENGTH sized buffer, then load\par
the information into those buffers.  When you need to play them you would mix\par
the channels into a small buffer then DMA that buffer out to the sound card.\par
\par
     - [SOUNDBLASTER] allocate a SAMPLE_LENGTH sized pointer to buffer in \par
       memory and load the sample into it\par
     - [DRAM-BASED-CARD (GUS)] poke/DMA bytes into DRAM, increment dword\par
       offset value GUS_OFFSET, and store that value next to the sample's\par
       information (along side length, volume, finetune, loop start etc)\par
     - check that your samples fit into (D)RAM, and exit with an error if\par
       they don't.\par
- end loop\par
\par
+---------------------+\par
\'a6 \'a6\'a6\'a6 2.8 Phew :) \'a6\'a6\'a6 \'a6\par
+---------------------+\par
Wasn't that bad was it? Now you have the FULL mod file stored away at your\par
disposal, with samples ready to blast.\par
\par
Suggestions:\par
============\par
Now is a GOOD time to do some thorough testing.  Do these things\par
\par
- Make sure your sample headers and information are stored correctly\par
- Make sure your pattern data is stored perfectly.. it's quite important you\par
  know :)\par
- Make sure your samples are stable in memory, and try to play them through\par
  your sound card.. you can have a few problems with misloaded samples I have\par
  found :)  Also make sure the loop points are played correctly!\par
- Make sure you deallocate your memory before quitting the program!!\par
\par
\par
\par
\par
+----------------------------------------------------------------------------+\par
\'a6                           \'a6\'a6\'a6  : SECTION 3 :  \'a6\'a6\'a6                          \'a6\par
\'a6                           \'a6\'a6\'a6 Playing the MOD \'a6\'a6\'a6                          \'a6\par
+----------------------------------------------------------------------------+\par
\par
+---------------------------------+\par
\'a6 \'a6\'a6\'a6 3.1 OK where do I start \'a6\'a6\'a6 \'a6\par
+---------------------------------+\par
\par
I think the main thing you need to do now once you are satisfied your MOD is\par
loaded properly, is to set up an interrupt function, and understand a bit\par
about the way a MOD is played.\par
\par
Im going to use the system timer to hook onto here as an example, and if you\par
want to use other interrupt servicers you can do that if you know how..\par
(ie GUS IRQ).\par
You should know how to set up an interrupt handler yourself, but ill describe\par
how to do it here with a bit of code to demonstrate. \par
\par
The system timer lies on INT 8\par
- Get the old handlers vector for int 8h, and store it away for later\par
- Set your new handler function to the vector for int 8h\par
\par
 +-------------------------------------------------------------------------+\par
 \'a6 REMEMBER TO REHOOK YOUR OLD TIMER TO ITS ORIGNAL PLACE WHEN THE SONG IS \'a6\par
 \'a6                               FINISHED!                                 \'a6\par
 +-------------------------------------------------------------------------+\par
\par
In C you would do that like this:\par
    oldhandler = _dos_getvect(8);\par
    setvect(8, handler);\par
\par
 - where oldhandler has to have the prototype globally declared as \par
   void interrupt ( *oldhandler)(...);\par
 - for dummies the actuall handler function looks like this\par
   \par
   void interrupt modhandler(...) \{ // yes put 3 dots in here\par
\tab ...                         // do main loop here\par
\tab oldmodhandler();            // this is here to return int8 to what it\par
\tab\tab\tab\tab     // normally did.  I'll crash without it.\par
   \}\par
\par
In PASCAL it would look something like this\par
    GetIntVec($8, Addr(OldTimer));\par
    SetIntVec($8, Addr(ModInterrupt));\par
\par
  - with the function looking something like (I have no idea if this is right\par
\tab\tab\tab\tab\tab       as I don't do pascal)\par
   \{ $ F+,S-,W-\}\par
   Procedure modhandler; Interrupt;\par
   Begin\par
   ...\par
   OldTimer;\par
   End;\par
   \{ $ F-,S+\}\par
\par
If you're still not sure in C or pascal, check out the online manual on \par
getvect/setvect etc..\par
\par
+---------------------------------------+\par
\'a6 \'a6\'a6\'a6 3.2 Setting the timer's speed \'a6\'a6\'a6 \'a6\par
+---------------------------------------+\par
Ok now your interrupt handler is already firing :) so one thing you must\par
do is set it to the right speed, we don't want mods that play way to fast or\par
slow, we want it at 125 BPM right now (or 50hz, or 50 ticks a second).\par
\par
How do you set the system timer's speed? if we want 50hz, we have to use\par
a divisor to calculate the right rate like so.\par
\par
Speed = 1193180/50        <- 50 hz here, 1193180 is the divisor.\par
\par
\tab mov dx, 0x43\par
\tab mov al, 0x36\par
\tab out dx, al\par
\tab mov dx, 0x40\par
\tab mov ax, Speed     <- here's the speed variable \par
\tab out dx, al\par
\tab shr ax, 8\par
\tab out dx, al\par
\par
Now the interrupt function should be ticking away at 50 times a second.\par
For other BPM's, which will be used because of the change tempo effect Fxy\par
with values of 20h and up.  If it is below 20h, then you change the SPEED and\par
not the BPM.  This is looked at later on.\par
\par
To convert BPM to HZ, you use :   \par
     HZ = 2 * BPM / 5           (i.e 125bpm = 50hz)\par
then SPEED = 1193180 / HZ  for the set timer routine.\par
\par
Simple huh.  You'll need this for effect Fxy, but don't worry about this until \par
later.\par
\par
+--------------------------+\par
\'a6 \'a6\'a6\'a6 3.3 Player Logic \'a6\'a6\'a6 \'a6\par
+--------------------------+\par
\par
Now lets take a look at the interrupt function, this is where the playing\par
is done.\par
\par
The SPEED of a song is the base on how your mod is played.  Each row of a\par
pattern is updated every SPEED number of clock ticks, so if a speed is 6,\par
then you only update each row every 6 clock ticks.  So on a speed like 3,\par
the row is going to be updated every 3 ticks and will play twice as fast as\par
speed 6.\par
  Inbetween you update certain tick sensitive effects, like portamentos, \par
volume slides and vibrato. \par
  Diagramatically the playing of a mod looks like this.\par
\par
SPEED IS 6\par
\par
tick#\par
+-+\par
0: UPDATE ROW #0    <- update the 4,6 or 8 notes here in a mod's row.\par
1: ---  \\\par
2: ---   \\\par
3: ---    >- certain effects are updated here\par
4: ---   /\par
5: ---  /\par
0: UPDATE ROW #1\par
1: ---\par
2: ---\par
3: ---\par
4: ---\par
5: ---\par
0: UPDATE ROW #2\par
etc..\par
\par
Logically a very basic representation of playing a mod looks like this:\par
+---------------------+\par
\'a6 STATIC TICK = SPEED \'a6  - declaration, start it off at SPEED, not 0, as we\par
\'a6                     \'a6    want straight into the 'if tick >= speed condition'\par
\'a6 TICK = TICK + 1     \'a6  - now increment the tick counter\par
\'a6 if TICK >= SPEED    \'a6  - if the tick # is bigger or equal than SPEED then\par
\'a6       update_row    \'a6  - update the CHANNEL number of notes for the new row\par
\'a6       tick =0       \'a6  - reset tick to 0\par
\'a6       ROW = ROW + 1 \'a6  - incrememnt our row\par
\'a6 else update_effect  \'a6  - else we update the tick based effects.\par
+---------------------+\par
But you will have to take into account there are only 64 rows in a pattern,\par
and if you hit 64 then jump to the next pattern and start at row 0 again.\par
I say 64 because row 63's effects have to be played out before you jump to\par
the next pattern.\par
\par
don't bother with update_effect for some time until you have got update_row\par
going ok.\par
\par
+--------------------------------+\par
\'a6 \'a6\'a6\'a6 3.3.1  Orders/Patterns \'a6\'a6\'a6 \'a6\par
+--------------------------------+\par
Just a short note on this.\par
When you reach the end of the pattern or whatever, you need to go to the next\par
order.  Now say you had your order pattern numbers stored in an array as they\par
should be, then it is simply a task of referencing that pattern number\par
according to the index ORDER, and then repositioning your pattern pointer\par
accordingly.\par
\par
ie. If your order list is something like this.\par
\tab +--------------------------+\par
  Order \'a6 0 1 2 3 4 5 6 7 8 9 .... \'a6\par
\tab\'a6--------------------------\'a6\par
Pattern \'a6 0 0 1 4 5 2 3 4 4 6 .... \'a6\par
\tab +--------------------------+\par
and you have an array of patterns set up as ORDER_TABLE[128].\par
Selecting the appropriate pattern is as simple as finding ORDER_TABLE[ORDER].\par
To find the offset in your buffer you should know how to do by now by using\par
some sort of formula like: \par
  \par
  offset = (CHANNELS * 4 * 64 * ORDER_TABLE[ORDER])\par
\tab\tab     bytes, rows\par
\par
and to find the current row just add (CHANNELS * 4 * row).\par
\par
so the pattern+row formula ends up as :\par
  offset = (CHANNELS * 4 * 64 * ORDER_TABLE[ORDER]) + (CHANNELS * 4 * row).\par
\par
I calculate this figure before processing every row and set the pattern\par
pointer, so that all I have to do is increment the row number or the order\par
number and this formula will pick it up for me and set the pointer\par
accordingly.\par
\par
+-------------------------------+\par
\'a6 \'a6\'a6\'a6 3.4 Inside update row \'a6\'a6\'a6 \'a6\par
+-------------------------------+\par
\par
Ok on every tick 0, we want to update CHANNELS number of channels\par
\par
PSEUDOCODE:\par
-----------\par
\par
- Point your note pointer to the correct offset in the pattern buffer, \par
  according to order and row\par
\par
Loop CHANNEL number of times \{\par
     get NOTE from buffer\par
     get SAMPLE from buffer\par
     get EFFECT from buffer\par
     get EFFECT_PARAMETER from buffer\par
\par
     if (SAMPLE > 0) then \{\par
\tab   LAST_INSTRUMENT[CHANNEL] = SAMPLE (we store this for later)\par
\tab   volume[CHANNEL] = default volume of sample#\par
\tab   SetVolume(volume[CHANNEL])      (actually do the hardware set here)\par
     \}\par
     if (period >= 0) then \{\par
\tab   if (EFFECT does not = 3 and EFFECT does not = 5) then\par
\tab       frequency[CHANNEL] = \par
\tab\tab\tab FREQ_TAB[NOTE + LAST_INSTRUMENT[CHANNEL]'s finetune]\par
     \}\par
\par
(freq_tab[] should be your amiga frequency lookup table - see sec 3.5)\par
     \par
\par
     (this line here is a bit of optimization for your player)\par
     if (effect# = 0 and parameter# = 0) then jump to SKIP_EFFECTS label\par
\par
     -----\par
     -----\par
     PROCESS THE NON TICK BASED EFFECTS (see section 5 how to do this)\par
     ALSO GRAB PARAMETERS FOR TICK BASED EFFECTS (like porta, vibrato etc)\par
     -----\par
     -----\par
\par
label SKIP_EFFECTS:\par
\par
     if (freqency[CHANNEL] > 0) then SetFrequency(frequency[CHANNEL])\par
     if (period > 0 OR sample_offset > 00FFh) then \{\par
\tab\tab      (Why 00FFh? because with sample offset anything below \par
\tab\tab       1 * 100h is considered 0.  See section 5.10 about this)\par
\tab   if (vibratowavecontrol = retrig waveform) then \{\par
\tab\tab vibrato_position[CHANNEL] = 0 (see section 5.5 about this)\par
\tab\tab vibrato_negative[CHANNEL] = 0 (see section 5.5 about this)\par
\tab   \}\par
\tab   if (tremolowavecontrol = retrig waveform) then \{\par
\tab\tab tremolo_position[CHANNEL] = 0 (see section 5.8 about this)\par
\tab\tab tremolo_negative[CHANNEL] = 0 (see section 5.8 about this)\par
\tab   \}\par
\tab   PLAYVOICE\par
\tab   * (here is gus biased, I guess for SB mixing you would mix in a \par
\tab      section of the sample into a small buffer and dma it out here.  \par
\tab      You also have to take note if the sample is looping or not.. GUS\par
\tab      does this for you of course ;) )\par
\tab   * (also remember to add the sample_offset value to the start of the\par
\tab      sample begin address.  If there was no sample offset then this\par
\tab      value would be 0 and it would not affect the outcome.)\par
     \}\par
     move pointer to next note in row (ie increment 4 bytes)\par
\}\par
\par
This is your main inner loop and the part that needs to be optimized.  So \par
make sure you can try and get it as fast as possible.\par
\par
*NOTE - setfrequency in this example is being passed amiga values, and should\par
\tab convert it to a relevant hardware value.\par
\par
+----------------------------------------------+\par
\'a6 \'a6\'a6\'a6 3.5 Period Frequencies and Fine Tune \'a6\'a6\'a6 \'a6\par
+----------------------------------------------+\par
\par
The formula for converting amiga period value to hz, is accomplished using\par
ONE of the following formulas.  Why there are 2 will be explained shortly.\par
You are going to have to convert amiga frequencies to some sort of speed or\par
frequency factor for YOUR sound card, so this part will show you how.\par
\par
PAL:   7093789.2 / (amigaval * 2)\par
NSTC:  7159090.5 / (amigaval * 2)\par
\par
Say if we wanted to find the value in hz for middle note C-2.  Looking up\par
the amiga table we see the value for C-2 is 428 (see table below).\par
\par
therefore:\par
\par
PAL:   7093789.2 / (428 * 2) = 8287.14hz\par
NSTC:  7159090.5 / (428 * 2) = 8363.42hz\par
\par
A quick explanation on PAL and NSTC.  The amiga used to time its mods by\par
sitting their interrupt handlers on the vertical retrace of the video screen\par
so the period values they used in the tables are the amount of data to send\par
to the amiga sound chip between interrupts, therefore changing the speed of\par
data sent and the pitch of the note.  Pretty stupid system huh.  But I suppose\par
back then they just wanted it to work and werent too worried about the future.\par
  Trackers like FastTracker 2 are taking a step in the right direction by\par
using linear frequency tables.. ST3 took a step backwards by trying to base\par
s3m on the mod format.  This is MUSIC we are talking about not computer\par
hardware.\par
\par
Which should I use? you are asking.  Well I think the NSTC is the most widely\par
accepted and used value, but it does not really matter.  The only difference\par
you might hear is a SLIGHT change in pitch, like about one fine tune out\par
say.  Inertia Play has a switch that lets you choose one or the other.  Try\par
flicking between the 2 while a song is playing to see what it is like.\par
\par
Here is a period table.  This is straight out of protracker so it is bugfree,\par
other tables you might see in like gusplay by cascada have bugs in it.  Don't\par
use it unless you can fix it.  (ie the bug is about F-2 with finetune -3 or\par
so.. FastTracker 1 has the bug try it out.)\par
\par
mt_PeriodTable\par
; Tuning 0, Normal\par
\tab dc.w 856,808,762,720,678,640,604,570,538,508,480,453 ; C-1 to B-1\par
\tab dc.w 428,404,381,360,339,320,302,285,269,254,240,226 ; C-2 to B-2\par
\tab dc.w 214,202,190,180,170,160,151,143,135,127,120,113 ; C-3 to B-3\par
; Tuning 1\par
\tab dc.w 850,802,757,715,674,637,601,567,535,505,477,450 ; same as above\par
\tab dc.w 425,401,379,357,337,318,300,284,268,253,239,225 ; but with \par
\tab dc.w 213,201,189,179,169,159,150,142,134,126,119,113 ; finetune +1\par
; Tuning 2\par
\tab dc.w 844,796,752,709,670,632,597,563,532,502,474,447 ; etc, \par
\tab dc.w 422,398,376,355,335,316,298,282,266,251,237,224 ; finetune +2\par
\tab dc.w 211,199,188,177,167,158,149,141,133,125,118,112\par
; Tuning 3\par
\tab dc.w 838,791,746,704,665,628,592,559,528,498,470,444\par
\tab dc.w 419,395,373,352,332,314,296,280,264,249,235,222\par
\tab dc.w 209,198,187,176,166,157,148,140,132,125,118,111\par
; Tuning 4\par
\tab dc.w 832,785,741,699,660,623,588,555,524,495,467,441\par
\tab dc.w 416,392,370,350,330,312,294,278,262,247,233,220\par
\tab dc.w 208,196,185,175,165,156,147,139,131,124,117,110\par
; Tuning 5\par
\tab dc.w 826,779,736,694,655,619,584,551,520,491,463,437\par
\tab dc.w 413,390,368,347,328,309,292,276,260,245,232,219\par
\tab dc.w 206,195,184,174,164,155,146,138,130,123,116,109\par
; Tuning 6\par
\tab dc.w 820,774,730,689,651,614,580,547,516,487,460,434\par
\tab dc.w 410,387,365,345,325,307,290,274,258,244,230,217\par
\tab dc.w 205,193,183,172,163,154,145,137,129,122,115,109\par
; Tuning 7\par
\tab dc.w 814,768,725,684,646,610,575,543,513,484,457,431\par
\tab dc.w 407,384,363,342,323,305,288,272,256,242,228,216\par
\tab dc.w 204,192,181,171,161,152,144,136,128,121,114,108\par
; Tuning -8\par
\tab dc.w 907,856,808,762,720,678,640,604,570,538,508,480\par
\tab dc.w 453,428,404,381,360,339,320,302,285,269,254,240\par
\tab dc.w 226,214,202,190,180,170,160,151,143,135,127,120\par
; Tuning -7\par
\tab dc.w 900,850,802,757,715,675,636,601,567,535,505,477\par
\tab dc.w 450,425,401,379,357,337,318,300,284,268,253,238\par
\tab dc.w 225,212,200,189,179,169,159,150,142,134,126,119\par
; Tuning -6\par
\tab dc.w 894,844,796,752,709,670,632,597,563,532,502,474\par
\tab dc.w 447,422,398,376,355,335,316,298,282,266,251,237\par
\tab dc.w 223,211,199,188,177,167,158,149,141,133,125,118\par
; Tuning -5\par
\tab dc.w 887,838,791,746,704,665,628,592,559,528,498,470\par
\tab dc.w 444,419,395,373,352,332,314,296,280,264,249,235\par
\tab dc.w 222,209,198,187,176,166,157,148,140,132,125,118\par
; Tuning -4\par
\tab dc.w 881,832,785,741,699,660,623,588,555,524,494,467\par
\tab dc.w 441,416,392,370,350,330,312,294,278,262,247,233\par
\tab dc.w 220,208,196,185,175,165,156,147,139,131,123,117\par
; Tuning -3\par
\tab dc.w 875,826,779,736,694,655,619,584,551,520,491,463\par
\tab dc.w 437,413,390,368,347,328,309,292,276,260,245,232\par
\tab dc.w 219,206,195,184,174,164,155,146,138,130,123,116\par
; Tuning -2\par
\tab dc.w 868,820,774,730,689,651,614,580,547,516,487,460\par
\tab dc.w 434,410,387,365,345,325,307,290,274,258,244,230\par
\tab dc.w 217,205,193,183,172,163,154,145,137,129,122,115\par
; Tuning -1\par
\tab dc.w 862,814,768,725,684,646,610,575,543,513,484,457\par
\tab dc.w 431,407,384,363,342,323,305,288,272,256,242,228\par
\tab dc.w 216,203,192,181,171,161,152,144,136,128,121,114\par
\par
* I personally used a sorted form of this table, that orders all the notes\par
  from C-1 with -8 finetune, then goes up through all the finetunes to B-3\par
  with finetune +7.  Makes things a lot easier I find.\par
\par
+---------------------------------------------+\par
\'a6 \'a6\'a6\'a6 3.5.1 What do I do with this table? \'a6\'a6\'a6 \'a6\par
+---------------------------------------------+\par
I pondered this one myself for a bit when I first started.  It would be nice\par
if you could just store in the amiga values as your notes, then give them to\par
your formula to use, and not even use a table to lookup amiga values.  \par
But there lies a problem.  Namely finetune and arpeggio.  If you have the\par
amiga values stored as notes, then you will have no idea how much to fine\par
tune according to the note you are on.  If it was a linear table it would be\par
fine (you would just say 'finetune = 2, so add 2 to the pitch'), but as it\par
is actually a logarithmic table adding 2 on a C1 note gives a totally\par
different tone to adding 2 on a C3 note.\par
\par
Forget storing the actual amiga periods as your notes, in your loader convert\par
the periods to note numbers (see section 2.6.1), so you can use it to look\par
up the period table later when the tune is playing.\par
\par
If you are still a bit confused this is how it is done.\par
\par
- Loading the pattern data, I looked up the amiga value loaded and gave it\par
  a number from 8 to 288.  (36 notes, multiply it by 8 for finetunes between,\par
  remember each note is 8 finetunes apart, so it equals 288.)\par
- start at 8 (C-1) because there are going to be 8 finetunes below C-1.\par
- finish at 288 (B-3), and rememer there is going to be 7 finetunes above\par
  it.\par
\par
- You get this value by reading in the amiga value from the file, and scan\par
  through the period table (given above) until you find a match.\par
  (some trackers don't save the right numbers so I used a check if the number\par
   was between -2 to +2 from the actual value).\par
  Once you find the corresponding value, store the note as your (counter*8) \par
  where counter was the value you were incrementing as you went through the\par
  table.\par
- Now the pattern data is loaded up with a nice linear set of notes.\par
\par
- when you actually play it just use your linear value as an index to look\par
  up the amiga table again to get the correct amiga period value.\par
\par
ok here's how I did it.\par
-----------------------\par
period = ((byte0 & 0xF) << 8) + byte1;   // read in the value from file\par
\par
current -> period = -1;                  // default value to -1, or 'nothing'\par
for (count2=1;count2<37; count2++) \{     // start the search\par
     if (period > freqtab[count2*8]-2 && period < freqtab[count2*8]+2 )\par
\tab   current -> period = count2*8;  // if found store the counter as\par
\}                                        // the index for the note.\par
\par
If we went through the whole table and didnt find the value, then it is\par
assumed there is no note, and it stays at -1.\par
\par
+------------------------------------+\par
\'a6 \'a6\'a6\'a6 3.5.2 Gravis UltraSound :) \'a6\'a6\'a6 \'a6\par
+------------------------------------+\par
\par
How to change to a GUS frequency???  Well you should find this sort of stuff\par
yourself but because im gus biased ill talk a bit about it :)\par
\par
Assuming 44khz mixing rate:\par
first :      hz = 7159090.5 / ( amigaval * 2 );\par
 next : gusfreq = ( hz / 44100) * 1024;\par
\par
simple huh.. the 44100 would change to whatever mixing rate you are using\par
depending on the amount of voices.  Ie say I use 20 voices so looking up\par
this table...\par
\par
   Frequency   Active Voices\par
\tab 44100          14 or lower\par
\tab 41160          15\par
\tab 38587          16\par
\tab 36317          17\par
\tab 34300          18\par
\tab 32494          19\par
\tab 30870          20\par
\tab 29400          21\par
\tab 28063          22\par
\tab 26843          23\par
\tab 25725          24\par
\tab 24696          25\par
\tab 23746          26\par
\tab 22866          27\par
\tab 22050          28\par
\tab 21289          29\par
\tab 20580          30\par
\tab 19916          31\par
\tab 19293          32\par
\par
..My formula becomes gusfreq = ( hz / 30870 ) * 1024;\par
BUT: with a bit of mathematical optimization I reduced this formula down to:\par
\par
hz = 7159090.50 / (freq * 2)             gusfreq = ( hz / 30870 ) * 1024\par
   = 3579545.25 / freq                           = hz / 30.14648438\par
\par
now: gusfreq = ( 3579545.25 / freq ) / 30.14648438\par
\tab      = 118738.3894 / freq\par
\par
#define GUSfreq(x)      118738/x\par
where x is the amiga value found in our period table.. saves a lot of \par
calculation huh! (cuts 4 divs/muls down to 1 div)\par
\par
ok ok.. I know you are too lazy to work out 44.1khz, so it \par
is 83117 / amigafreq.\par
\par
+--------------------+\par
\'a6 \'a6\'a6\'a6 3.6 Volume \'a6\'a6\'a6 \'a6\par
+--------------------+\par
Handling volumes is one of the simplest parts of coding your player.  It\par
is just a matter of looking up a table or adjusting the percentage of\par
the sample to be mixed into the final output.\par
\par
Remember there are actually 65 volume settings, just when you thought there\par
were only 64 (040h) :).  0 is included which is absolutely no volume, and 64\par
is full volume.\par
\par
For gus users this is one of the best volume tables I have found anywhere.\par
I have about 5 volume tables and this one is the one I use, it is quite loud\par
but not so loud to cause bad clipping.  Others I found are too soft.\par
\par
word GUSvol[] = \{\par
\tab 0x1500,\par
\tab 0x9300,0xA900,0xB400,0xBC00,0xC180,0xC580,0xC980,0xCD80,\par
\tab 0xCF40,0xD240,0xD440,0xD640,0xD840,0xDA40,0xDC40,0xDE40,\par
\tab 0xDEF0,0xDFA0,0xE1A0,0xE2A0,0xE3A0,0xE4A0,0xE5A0,0xE6A0,\par
\tab 0xE7A0,0xE8A0,0xE9A0,0xEAA0,0xEBA0,0xECA0,0xEDA0,0xEEA0,\par
\tab 0xEEF0,0xEFE0,0xEF60,0xF1E0,0xF160,0xF1E0,0xF260,0xF2E0,\par
\tab 0xF360,0xF3E0,0xF460,0xF4E0,0xF560,0xF5E0,0xF660,0xF6E0,\par
\tab 0xF760,0xF7E0,0xF860,0xF8E0,0xF960,0xF9E0,0xFA60,0xFAF0,\par
\tab 0xFB70,0xFBF0,0xFC70,0xFCF0,0xFD70,0xFD90,0xFDB0,0xFDD0\par
\};\par
\par
\par
+----------------------------------------------------------------------------+\par
\'a6                           \'a6\'a6\'a6  : SECTION 4 :  \'a6\'a6\'a6                          \'a6\par
\'a6                           \'a6\'a6\'a6  Miscellaneous  \'a6\'a6\'a6                          \'a6\par
+----------------------------------------------------------------------------+\par
\par
This section describes some of the little things that should be taken note of\par
when writing a mod player, but are VERY important.\par
\par
+-------------------------------------------------------------+\par
\'a6 \'a6\'a6\'a6 4.1 Notes Without Instrument Numbers or Frequencies \'a6\'a6\'a6 \'a6 *IMPORTANT*\par
+-------------------------------------------------------------+\par
This subsection is just about the most important of this whole section.\par
Sometimes a composer will some seemingly strange methods to write a tune,\par
i.e. leaving an instrument number off, or putting an instrument number but\par
with no note!  This part describes how to combat this.\par
\par
NO INSTRUMENT NUMBER:\par
---------------------\par
C-2 01 C10\par
D-2 00 301 <- note no instrument number\par
--- 00 300\par
\par
You will notice, on the porta to note that the composer has left off the \par
instrument number.  Also notice that the previous note had the volume set\par
to 10.  Leaving off an instrument number causes the volume to stay as it is,\par
and so the note slides, but still stays at volume 10.\par
\par
NO PERIOD VALUE OR NOTE:\par
------------------------\par
C-1 01 A07\par
--- 01 A07 <- no period value (note), but there are instrument numbers\par
--- 01 A07\par
--- 01 A07\par
\par
What this does is reset the volume on every note, and slides the volume down\par
on every note too.. This gives a stuttering effect that is commonly used.\par
It reinforces the last part (no instrument number), that if there is an\par
instrument number, then the volume is reset to the sample's default volume.\par
\par
NOTE BUT NOTHING ELSE:\par
----------------------\par
C-1 01 000\par
D-1 00 000\par
E-1 00 000\par
\par
This means the sample is reset to its starting position, on all 3 notes.\par
\par
CONCLUSION:\par
-----------\par
\par
- ONLY RESET VOLUME IF THERE IS AN INSTRUMENT NUMBER\par
- ONLY RESET PITCH IF THERE IS A PERIOD VALUE/NOTE\par
- ONLY RESET SAMPLE IF THERE IS A PERIOD VALUE/NOTE (and no effect 3xy, 5xy \par
\tab\tab\tab\tab\tab\tab        or EDx)\par
\par
\par
+----------------------------------------------------------------------------+\par
\'a6                           \'a6\'a6\'a6  : SECTION 5 :  \'a6\'a6\'a6                          \'a6\par
\'a6                           \'a6\'a6\'a6     Effects     \'a6\'a6\'a6                          \'a6\par
+----------------------------------------------------------------------------+\par
\par
This part of the document is one of the most sorely needed, it actually tells\par
you HOW to code the effect, not just some vague reference on it and a basic\par
explanation like I have seen in so many other docs.\par
\par
TERMINOLOGY:\par
============\par
Beside each effect, there are the 2 Y/N boxes.. these are;\par
\par
       T0 : (TICK 0) This means the effect is updated or taken care of at the \par
\tab     start of the row, or when the row is first encountered.\par
INBETWEEN : This means the effect is updated on the other (speed-1) ticks \par
\tab     that lie inbetween rows.\par
\par
When coding your player, go for effect Cxy first.  It is the easiest and most\par
substantial effect to enable.  It will even make your tune resemble its\par
normal self :).  Then go for effect Fxy (set speed).\par
\par
+-----------------------------------+\par
\'a6 \'a6\'a6\'a6 5.1 Effect 0xy (Arpeggio) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]  \par
+-----------------------------------+\par
This effect alternates the pitch rapidly to simulate a chord.  It usually\par
sounds very grating or harsh so it isnt used much except for chip tunes.\par
\par
EG: \par
C-2 01 047 (I want to add to the pitch by 4 half notes then 7)\par
\par
Range: x = 1st semitone to add to note (0h-Fh)\par
       y = 2nd semitone to add to note (0h-Fh)\par
\par
so the effect 047 would generate a major, while effect 037 causes a minor.\par
\par
This is a tick based effect:\par
Tick 0 Do nothing,\par
Tick 1 you add the x arg, \par
Tick 2 you add the y arg,\par
Tick 3 you reset the frequency\par
.... go back and do from tick 1 until we reach the next row\par
\par
You notice if SPEED is 1, then there will be no arpeggiation because there\par
are no ticks inbetween.  If SPEED is 2, then only the x arg is taken into\par
account.\par
Each note is 8 fine tunes apart, so use your finetune table to calculate the\par
next row down if you like, or use a special arpeggio table to find the values\par
to add.\par
\par
It is done something like this:\par
- increment arpcounter by 1\par
- if arpcounter > 2 arpcounter = 0\par
- if arpcounter = 0 set the frequency to the normal value\par
- if arpcounter = 1 set the frequency to the normal value + x # of finetunes\par
- if arpcounter = 2 set the frequency to the normal value + y # of finetunes\par
\par
+-----------------------------------+\par
\'a6 \'a6\'a6\'a6 5.2 Effect 1xy (Porta Up) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]  \par
+-----------------------------------+\par
This effect causes a pitch slide that goes up.\par
\par
EG: \par
C-2 01 104 (I want to slide the frequency up 4 amiga values every tick)\par
--- 00 104 (slide againt 4 values every tick)\par
\par
Range: xy = 00h-FFh\par
\par
You do this by resetting the frequency every tick, EXCEPT for the first one.\par
The amount to slide by is the value given in EFFECT_PARAMETER\par
You add the value to the AMIGA value of the frequency.\par
\par
Tick 0 Do nothing.\par
Tick 1 add EFFECT_PARAMETER to the amiga frequency, and set it.\par
Tick 2 add EFFECT_PARAMETER to the amiga frequency, and set it.\par
Tick 3 add EFFECT_PARAMETER to the amiga frequency, and set it.\par
.... keep going until end of note\par
\par
Remember B-3 is the highest note you can use, there is no law against sliding\par
above it but it is not standard (some mods might be written thinking that \par
the porta WILL stop at B-3, so be carefull).  Personally I stop at 54, or \par
approximately B-5.\par
\par
+-------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.3 Effect 2xy (Porta Down) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]  \par
+-------------------------------------+\par
This effect causes a pitch slide that goes down.\par
\par
EG: \par
C-2 01 204 (I want to slide the frequency down 4 amiga values every tick)\par
--- 00 204 (slide again 4 amiga values every tick)\par
\par
Range: xy = 00h-FFh\par
\par
You do this by resetting the frequency every tick, EXCEPT for the first one.\par
The amount to slide by is the amound given in EFFECT_PARAMETER.\par
You subtract the value from the AMIGA value of the frequency.\par
\par
Tick 0 Do nothing.\par
Tick 1 subtract EFFECT_PARAMETER from the frequency, and set it.\par
Tick 2 subtract EFFECT_PARAMETER from the frequency, and set it.\par
Tick 3 subtract EFFECT_PARAMETER from the frequency, and set it.\par
.... keep going until end of note\par
\par
Be careful you don't slide too low.  Going below C-1 is non standard, and \par
going below a frequency of 1 could cause horrible side effects :)\par
\par
+----------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.4 Effect 3xy (Porta To Note) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [Y]  \par
+----------------------------------------+\par
This effect causes the pitch to slide towards the note specified.\par
If there is no note specified it slides towards the last note specified in\par
the Porta to Note effect.\par
If no parameter use the last porta speed used for that channel.\par
\par
EG: \par
C-2 01 000 \par
D-2 01 301 (I want to set D-2 as the note to slide towards, and with a speed\par
--- 00 300  of 1, then I just want to keep it sliding to D-2, and you already\par
--- 00 300  know the speed so I wont bother telling you again)\par
--- 00 300\par
\par
Range: xy = 00h-FFh\par
\par
This effect can be buggy at first, but not too hard.\par
on TICK 0:\par
- If there is an argument given to the effect, then you must record that as \par
  PORTA_SPEED[channel]. (You need to remember all 4-8 channels worth of porta \par
  information - I have them as a global array)\par
- If there is a note given, then you must store that as \par
  NOTE_TO_PORTA_TO[channel].\par
- But don't slide here, just like the other porta effects.\par
- also, don't reset the note like you would normally if there was a frequency\par
  given (i.e. the D-2 in our example)\par
\par
On OTHER ticks:\par
- Subtract or add PORTA_SPEED to the frequency (in AMIGA units), and set it.\par
  Subtract or add depending on if the current frequency is smaller or larger\par
  than NOTE_TO_PORTA_TO.\par
\par
+----------------------------------+\par
\'a6 \'a6\'a6\'a6 5.5 Effect 4xy (Vibrato) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]  \par
+----------------------------------+\par
This effect causes the pitch to waver up and down around the base note.\par
If no parameter use the last vibrato parameters used for that channel.\par
\par
EG:\par
D-2 01 4A2 <- I want to vibrato the note D-2 with speed of A, and depth of 2\par
--- 00 400 <- Keep vibrating at A2 \par
--- 00 4B3 <- now change to B3\par
--- 00 400 <- Continue vibrating at B3\par
\par
Range: x = speed to vibrate at (0h-Fh)\par
       y = depth of vibrato (0h-Fh)\par
\par
This is simply a case of getting a sine table (the default wavecontrol - see\par
section 5.20 for other vibrato wavecontrols), and following along it \par
adjusting the frequency by adding or subtracting the value found according to\par
the the position of the table, which is incremented by VIBRATO_SPEED. \par
(ie you skip through the sine table VIBRATO_SPEED positions every tick)\par
\par
On TICK 0 the 2 vibrato values (position and neg flag) should be cleared to 0 \par
if a new note is played, so we restart the waveform at the start again.\par
\par
Positioning vibrato pointer\par
----------------------------\par
There are 32 positions in the sine table.  You want to ADD the values in\par
the sinetable to the frequency, then once it gets to the end, you want to\par
go back and SUBTRACT the same values from the frequency.  This gives a nice\par
wave.   The reason we do this is because the sine table only contains half\par
a wave (ie. a bump - see diagram).  Running through it once then turning it\par
upside down by negating it would produce a smooth running wave which\par
oscillates up and down..\par
\par
\tab +1|       ****        /At this point we subtract from frequency                 \par
\tab   |    ***    ***    /\par
Current 0 |****          ***|****          ****   -> time\par
\tab   |                 |    ***    ***\par
\tab -1|                 |       ****\par
\tab\tab\tab     32\par
\par
So once your VIBRATO_POS has gone past 32, then subtract 32 from it so it \par
starts at a respectable place at the beginning again. THEN change the \par
negation flag (ie flag: 0 for add values, 1 for subtract values).\par
\par
Sine Table\par
----------\par
This is the sine table used by Protracker.  If a player calls itself\par
fully protracker compatible, it really should be using this table.  GUSPlay\par
by Cascada uses a table that is slightly different, but I cant hear the\par
difference :)\par
\par
\tab    0, 24, 49, 74, 97,120,141,161,\par
\tab  180,197,212,224,235,244,250,253,\par
\tab  255,253,250,244,235,224,212,197,\par
\tab  180,161,141,120, 97, 74, 49, 24\par
\par
Calculating depth\par
-----------------\par
To calculate the amount or depth of the vibrato, you multiply the siner value\par
by the effect parameter y, THEN you divide it by 128.  Remember the divide\par
by 128 (or shift right 7bits) must be implemented or you'll have some HUGE\par
vibrato :)\par
\par
Setting the frequency.\par
----------------------\par
- Work out the size of the delta (delta means how much to add or subtract)\par
- ie. delta = vibrato_depth[CHANNEL] * sine_table[vibrato_pos[CHANNEL] / 128\par
-     if vibrato_negflag[CHANNEL] = 0, then SetFrequency(freq[CHANNEL]+delta)\par
-   else SetFrequency(freq[CHANNEL] - delta)\par
\par
Example code.\par
-------------\par
For those interested this is how mine works, but I don't think it is 100%\par
\par
if (effect == 0x4 || effect == 0x6) \{\par
\tab // work out the delta\par
\tab vib = vibdep[track]*sintab[vibpos[track]] >> 7;     // >> 7 = div 128\par
\tab\par
\tab // add the delta to the track's frequency if neg flag = 0\par
\tab // subtract the delta to the track's frequency if neg flag = 1\par
\tab if (vibneg[track] == 0) GUSSetFreq(track, GUSfreq(freq[track]+vib));\par
\tab else                    GUSSetFreq(track, GUSfreq(freq[track]-vib));\par
\par
\tab vibpos[track]+=vibspe[track];           // increment vib position\par
\tab\par
\tab if (vibpos[track] > 31) \{\par
\tab\tab vibpos[track] -=32;                      // jump back to start\par
\tab\tab if (vibneg[track]==0) vibneg[track] = 1; // change neg flag\par
\tab\tab else vibneg[track]=0;\par
\tab\}\par
\}\par
\par
+--------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.6 Effect 5xy (Porta + Vol Slide) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]  \par
+--------------------------------------------+\par
This is a combination of Porta to Note (3xy), and volume slide (Axy).\par
The parameter does not affect the porta, only the volume.\par
If no parameter use the last porta to note parameter used for that channel.\par
\par
EG:\par
C-1 01 000\par
D-1 01 301  <- start porta to note using speed of 3.\par
--- 00 501  <- from here on keep doing porta, but slide volume down 1 as well.\par
--- 00 501\par
--- 00 501\par
\par
Range: x = amount to slide volume up by or (0h-Fh)\par
       y = amount to slide volume down by. (0h-Fh)\par
\par
This is exactly what it means, just do a 3xy first, then do a volume slide.\par
The arguments only refer to the volume slide though and do not affect the\par
porta.  The porta is carried on from the last porta to note.\par
So when you code your effect routine, it's like\par
\par
if (effect = 03h OR effect = 05h) DO_PORTA_TO_NOTE\par
if (effect = 0Ah OR effect = 05h) DO_VOLUME_SLIDE\par
\par
kill 2 birds with 1 stone!\par
\par
+--------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.7 Effect 6xy (Vibrato+Vol Slide) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]  \par
+--------------------------------------------+\par
This is a combination of Vibrato (4xy), and volume slide (Axy).\par
The parameter does not affect the vibrato, only the volume.\par
If no parameter use the vibrato parameters used for that channel.\par
\par
EG:\par
C-1 01 4A2  <- start Vibrato with speed 0Ah, and depth 2.\par
--- 00 601  <- from here on keep doing vibrato, but slide volume down 1 as \par
--- 00 601     well.\par
--- 00 601\par
\par
Range: x = amount to slide volume up by or, (0h-Fh)\par
       y = amount to slide volume down by. (0h-Fh)\par
\par
This is exactly like effect 5xy, but just do a 4xy first, then do a volume \par
slide.\par
The arguments only refer to the volume slide though and do not affect the\par
vibrato.  The Vibrato is carried on from the Vibrato.\par
So when you code your effect routine, it's like\par
\par
if (effect = 04h OR effect = 06h) DO_PORTA_TO_NOTE\par
if (effect = 0Ah OR effect = 06h) DO_VOLUME_SLIDE\par
\par
kill 2 birds with 1 stone again! (hrmm thats 4 birds now :)\par
\par
+----------------------------------+\par
\'a6 \'a6\'a6\'a6 5.8 Effect 7xy (Tremolo) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]  \par
+----------------------------------+\par
This effect causes the volume to oscillate up and down in a fluctuating style\par
around the current volume, like vibrato but affecting volume not pitch.\par
If no parameter use the last tremolo parameter used for that channel.\par
\par
EG:\par
C-2 01 772 (I want to vibrate the volume up and down using speed 7 & depth 2)\par
--- 00 700 (continue with the tremolo at 7,2)\par
\par
Range: x = speed to vibrate volume at (0h-Fh)\par
       y = depth of tremolo (0h-Fh)\par
\par
Seeing as this is a similar effect to vibrato, then we will use the same\par
tables as it does.  The only difference with tremolo is that you divide the\par
delta (or deviation) by 64 and not 128.  You also have to check for if the\par
volume goes over or under 0 and 64.\par
This means if the biggest value in the sine table 255 is divided by 64,\par
then the biggest deviation with depth parameter of 1 would only be 4, on its\par
peak.\par
You're probably asking, what if the volume of the channel is 64?  Well in\par
this case you would only hear the negative side of the tremolo, when the\par
volume dips down and then back to full.  Same for the vice versa case if\par
the volume is set to 0.\par
\par
On TICK 0 the 2 tremolo values (position and neg flag) should be cleared to 0 \par
if a new note is played, so we restart the waveform at the start again.\par
\par
This is how it works.\par
- Work out the size of the delta (delta means how much to add or subtract)\par
- ie. delta = tremolo_depth[CHANNEL] * sine_table[tremolo_pos[CHANNEL] / 64\par
      if tremolo_negflag[CHANNEL] = 0, then \{\par
\tab      check if volume[CHANNEL] + delta > 64 and clip delta accordingly\par
\tab      SetVolume(volume[CHANNEL]+delta)\par
      \}\par
      else \{\par
\tab      check if volume[CHANNEL] - delta < 0 and clip delta accordingly\par
\tab      SetVolume(volume[CHANNEL] - delta)\par
      \}\par
- increase tremolo_position pointer and set neg flag accordingly (For any \par
more information check vibrato because they really are the same.  It is\par
explained in more detail, and the sine table mentioned is stored in there\par
also.)\par
\par
+------------------------------+\par
\'a6 \'a6\'a6\'a6 5.9 Effect 8xy (Pan) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]  \par
+------------------------------+\par
This effect is non-Protracker, but is worth mentioning.  It was introduced\par
by Otto Chrons in DMP (dual mod player), and causes the left/right position \par
of the current channel to be set to the position specified.  Hence Panning.\par
\par
EG:\par
--- 00 800              (Set the position of the channel to the far left)\par
\par
00 = far left\par
40 = middle\par
80 = far right\par
A4 = surround *\par
\par
(* Surround is usually achieved by having 2 copies of the sample, 1 inverted,\par
   and you play them at -exactly- the same time, with one of the pair panned\par
   fully left, and the other (the inverted one say) panned fully right.  This \par
   will give a surround effect.  If you play both the samples in the same pan\par
   position they will cancel each other out.  Experiment with this in a\par
   tracker.  Using GoldWave(tm) you can invert a sample.\par
   As efffect 8xy is a channel command, you will have to in effect have 2\par
   channels (voices) ready for this channel, and make sure you set one\par
   voice to the full left, and the other inverted, and to the full left.\par
   You CAN have surround sound on a GUS.)\par
\par
+-----------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.10 Effect 9xy (Sample Offset) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+-----------------------------------------+\par
This effect causes the note to start playing at an offset into the sample,\par
instead of just from the start.  It is used so that the beginning of a sample\par
is not played, but skipped.\par
\par
EG:\par
C-2 01 942 (I want to start the note playing at 4200h bytes into the sample)\par
\par
Range: xy = 00h-FFh\par
\par
As seen in the example, the argument is the first 2 digits of a 4 digit\par
number (in hex) that the offset should take place from.\par
\par
so SAMPLE_OFFSET = EFFECT_PARAMETER * 0100h\par
\par
What you do to enable this effect is when you tell your soundcard or mixing\par
buffer the start of the sample, also add to it the value SAMPLE_OFFSET and\par
then play it.  Quite simple really.\par
\par
Remember to check if the user set an offset that is larger than the sample!\par
\par
+----------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.11 Effect Axy (Volume Slide) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]\par
+----------------------------------------+\par
This effect causes the volume of the track to slide up or down.\par
\par
EG:\par
A-2 01 A01  <- slide the volume down 1 * (speed-1) units\par
--- 00 A01  <- slide the volume down 1 * (speed-1) units\par
--- 00 A01  <- slide the volume down 1 * (speed-1) units\par
--- 00 A20  <- now slide the volume up 2 * (speed-1) units\par
--- 00 A20  <- slide the volume up 2 * (speed-1) units\par
\par
Range: x = amount to slide volume up by or, (0h-Fh)\par
       y = amount to slide volume down by. (0h-Fh)\par
\par
On this affect you either slide the volume up x, or down y, but not both.\par
This is a tick based effect so should be processed once a tick but not tick 0.\par
if x > 0 then slide volume up x\par
if y > 0 then slide volume down y\par
if x > 0 and y > 0 then do nothing.\par
\par
On tick 0:\par
Take note of the volume slide, but do nothing\par
\par
On other ticks:\par
if x > 0 then add x to volume[CHANNEL] and set the volume\par
if y > 0 then subtract y to volume[CHANNEL] and set the volume\par
\par
* before setting the volume, make sure you havent slid past 0 or 64.\par
\par
+-------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.12 Effect Bxy (Jump To Pattern) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+-------------------------------------------+\par
This effect jumps to a specified channel (in hex)\par
\par
EG:\par
--- 00 B10 (I want to jump to order 10h, or 16)\par
\par
Range: xy = 00h-FFh\par
\par
This effect is fairly simple, after the ticks for the note are finished, \par
then reset the position of the order, starting at row 0 again.\par
Make sure you don't jump over the end of the song length, and if you do then\par
set it to the last order.\par
  \par
* if you increment your row after your PlayNote() function, then row should\par
  be set to -1, so it is 1 less than 0, then as the tick handler adds 1 to\par
  the row it is 0 again, and nothing is wrong.\par
\par
+--------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.13 Effect Cxy (Set Volume) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]  \par
+--------------------------------------+\par
This effect sets the volume of a channel.\par
\par
EG:\par
C-2 01 C20 (I want to set the volume of the channel to 20h)\par
\par
Range: xy = 00h-40h\par
\par
This is about the easiest and first effect you should code.  It is just a\par
simple case of setting the tracks volume to the argument specified (in hex)\par
The volume cannot be set past 40h, and if it is then set it to 40h.\par
Only process this effect on tick 0, and likewise only set the volume on tick\par
0.\par
\par
+-----------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.14 Effect Dxy (Pattern Break) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]  \par
+-----------------------------------------+\par
This effect breaks to the next pattern starting at the specified row.\par
\par
EG:\par
--- 00 D32 (I want to break from this pattern and start at row 32h on the next\par
\tab     pattern)\par
\par
Range: xy = 00h-3Fh (0-63 decimal)\par
\par
This effect is similair to effect Bxy or pattern jump.  You only jump to \par
the next pattern though, and you start tracking again at the specified row.\par
The row should not be bigger than 63, and if it is take it as 0.\par
It works something like this:\par
  - increment order (only once, some mods have more than 1 pbreak on a row\par
\tab\tab       which could cause an increment order twice or more!)\par
  - set row to be x*10 + y. (we have to get the decimal value not the hex)\par
  \par
* if you increment your row after your PlayNote() function, then row should\par
  be set to (x*10+y -1), so it is 1 less, then as the tick handler adds 1 to\par
  to the row again, nothing is wrong.\par
\par
+-------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.15 Effect Fxy (Set Speed) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]  \par
+-------------------------------------+\par
This effect sets the speed of the song or the BPM.\par
\par
EG:\par
--- 00 F07 (I want to set the speed of the song to 7 ticks a row)\par
--- 00 F7D (I want to set the bpm of the song to 125 or 7Dh)\par
\par
Range: xy = 00h-1Fh for speed\par
       xy = 20h-FFh for BPM\par
\par
This has 2 parts to it.  If the user specifies a parameter from 0 - 1Fh, then\par
it is just simply a case of setting your speed variable, otherwise you need\par
to set your bpm variable and reset the timer speed.  This is demonstrated in\par
section 3.2 on how to change the speed of the system timer according to \par
beats per minute.\par
\par
+--------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.16 Effect E0x (Set Filter) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]  \par
+--------------------------------------+\par
This effect turns on or off the hardware filter (not applicable to most pc\par
sound cards)\par
\par
EG:\par
--- 00 E01 (I want to turn the filter on)\par
--- 00 E00 (I want to turn the filter off)\par
\par
Range: x = 0 to turn hardware filter off, 1 to turn it on (0-1)\par
\par
There isnt much to say about this effect, except for that it is a hardware\par
function which was designed to turn on the amiga's filter.\par
If you wanted to you could try implementing this effect in the SBPro's h/w\par
filter.\par
\par
+-----------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.17 Effect E1x (Fine Porta Up) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]  \par
+-----------------------------------------+\par
This effect slides the pitch up by x amiga value's per row.\par
\par
EG:\par
C-2 01 E11 (I want to start at note C-2, and move pitch up one amiga value)\par
--- 00 E11 (keep sliding up...)\par
--- 00 E11\par
\par
Range: x= amount to slide up by. (0h-Fh)\par
\par
This effect is only processed once per row, on tick 0, and it is as simple\par
as just subtracting x from the current channel's frequency. (remember you\par
subtract to raise the pitch.)  You don't subtract any finetunes or anything,\par
just do a straight subtraction of x from the amigaval.\par
\par
+-------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.18 Effect E2x (Fine Porta Down) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]  \par
+-------------------------------------------+\par
This effect slides the pitch down by x amiga value's per row.\par
\par
EG:\par
C-2 01 E21 (I want to start at note C-2, and move pitch down one amiga value)\par
--- 00 E21 (keep sliding down...)\par
--- 00 E21\par
\par
Range: x = amount to slide pitch down by. (0h-Fh)\par
\par
This is identical to effect E2x, except but you add to the amigaval of the \par
channel by x, and don't subtract.\par
\par
+--------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.19 Effect E3x (Glissando Contrl) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]  \par
+--------------------------------------------+\par
This effect causes a change in the effect 3xy (porta to note).  It toggles\par
whether to do a smooth slide or whether to slide in jumps of semitones.\par
\par
EG:\par
--- 00 E31 (I want to turn on Glissando and have portas slide in semitones)\par
--- 00 E30 (I want to turn off Glissando and have portas slide smoothly)\par
\par
Range: x = 0 to turn off glissando, 1 to turn it on (0-1)\par
\par
By default this value should be set as 0, or doing a smooth slide.  It is\par
achieved by adding or subtracting the desired porta value too or from the\par
amiga value in effect 3xy, but you already knew that :).  \par
With glissando turned on it is a different story.  It is just simply a case\par
of setting the frequency to the next highest semitone (or 8 finetune values)\par
if you are sliding the pitch up, and vice versa for going down.\par
To implement this just keep a gliss flag and check it while doing your porta\par
effect in your UpdateEffect function.\par
\par
+--------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.20 Effect E4x (Vibrato Waveform) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+--------------------------------------------+\par
This effect set the waveform for the vibrato command to follow.\par
\par
EG:\par
--- 00 E42 (I want to select the squarewave function for the vibrato command)\par
--- 00 E40 (I want to select the default sinewave for the vibrato command)\par
\par
Range: x = vibrato function to select (0-7)\par
\par
The following values of x select its corresponding vibrato function\par
x=0 : Set sine wave  (default)\par
x=1 : Set Ramp Down  |\\|\\|\\     _   _\par
x=2 : Set Squarewave         |_| |_| |_\par
x=3 : Set Random     (anywhere)\par
x=4 : don't retrig Sine waveform\par
x=5 : don't retrig RampDown waveform\par
x=6 : don't retrig Squarewave waveform\par
x=7 : don't retrig random waveform\par
\par
- Sine wave is covered in the vibrato section (5.5), just apply a sine wave\par
  to the frequency.\par
- Square wave is simply subtracting and adding the VIB_DEPTH*256\par
  (then divided by 128) to the current frequency, alternating the\par
  add/subtract every VIB_SPEED number of ticks.\par
- retrig waveform means that you start the vibrato waveform from position 0\par
  everytime a new note is played.  If you have set the wave control flag to\par
  4 or more, then the waveform is not restarted, and just continues from the\par
  previous position in the vibrato waveform.\par
\par
+----------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.21 Effect E5x (Set Finetune) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+----------------------------------------+\par
This effect sets the finetune on a selected instrument.\par
\par
EG:\par
--- 01 E5F (I want to set the finetune of instrument 1 to -1)\par
\par
Range: x = value of finetune to set (0h-0Fh)\par
\par
if the value is > 7, just subtract 16 from it to get the signed value.\par
(ie. 0-7 = 0-7, and 8-15 = -8 to -1)\par
This effect is really easy, and I don't know why more players support it,\par
apart from it being a useless effect :).\par
To implement it, just\par
- check the instrument number\par
- get the finetune value in the effect\par
- set the finetune for that instrument.\par
\par
+----------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.22 Effect E6x (Pattern Loop) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+----------------------------------------+\par
This effect allows the user to loop a part of a pattern x number of times.\par
\par
EG:\par
C-2 01 E60 (I want to set the loop start at this point)\par
--- 00 000\par
--- 00 E64 (I want to loop back to the starting point 4 times)\par
\par
Range: x=marks loop starting point, or sets the number of times to loop to \par
\tab  the starting point (0h-0Fh)\par
\par
This effect is done in the following fashion.\par
- If parameter x = 0, note down the row number\par
- if parameter x > 0, then\par
    - if PATTERN_LOOP = 0, then set PATTERN_LOOP = x\par
\tab  else PATTERN_LOOP = PATTERN_LOOP -1\par
    - if PATTERN_LOOP > 0 row = stored row number.   (if we are still looping\par
\tab\tab\tab\tab\tab\tab\tab       then jump back)\par
\par
Remember when declaring the PATTERN_LOOP variable to initialize it as 0.\par
Jumping back should just be a matter of setting your row number to the stored\par
pattern loop number, and once the row is finished it should start playing at\par
the specified position again.\par
This is how my function works, in the UPDATE_NOTE function, or handler for\par
tick 0.\par
case 0x6 : if (eparmy == 0) patlooprow = row;   // store position of param=0\par
\tab    else \{\par
\tab\tab if (patloopno == 0) patloopno=eparmy;   // set times if 0\par
\tab\tab else patloopno--;                       // else subtract 1\par
\tab\tab if (patloopno > 0) row = patlooprow-1;  // if looping do jump\par
\tab    \}\par
\par
+--------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.23 Effect E7x (Tremolo WaveForm) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+--------------------------------------------+\par
This effect set the waveform for the tremolo command to follow, just like\par
vibrato.\par
\par
EG:\par
--- 00 E42 (I want to select the squarewave function for the tremolo command)\par
--- 00 E40 (I want to select the default sinewave for the tremolo command)\par
\par
Range: x = tremolo function to select (0-7)\par
\par
The following values of x select its corresponding tremolo function\par
x=0 : Set sine wave  (default)\par
x=1 : Set Ramp Down  |\\|\\|\\     _   _\par
x=2 : Set Squarewave         |_| |_| |_\par
x=3 : Set Random     (anywhere)\par
x=4 : don't retrig Sine waveform\par
x=5 : don't retrig RampDown waveform\par
x=6 : don't retrig Squarewave waveform\par
x=7 : don't retrig random waveform\par
\par
see section 5.20 for information.\par
\par
+------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.24 Effect E8x (16 pos panning) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+------------------------------------------+\par
This effect lets you do 16 position panning\par
\par
EG:\par
--- 00 E80 (I want to set the channel's pan value to the far left)\par
--- 00 E8F (I want to set the channel's pan value to the far right)\par
\par
Range: x=position to pan too (0h-0Fh)\par
\par
On tick 0, just read in the parameter and set the relative panning value for\par
the channel.\par
\par
+---------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.25 Effect E9x (Retrig Note) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]\par
+---------------------------------------+\par
This effect retiggers the current note every x ticks.\par
\par
EG:\par
C-2 01 E93 (I want to retrig the note every 3 ticks - at speed 6 this would\par
--- 00 000                                            retrig it only once)\par
C-2 01 E91 (I want to retrig the note every tick - at speed 6 this would\par
\tab\tab\tab\tab\tab\tab    retrig the note 5 times)\par
Range: x=ticks between retriggers (0h-0Fh)\par
\par
On this effect you need to use the modulus operator to check when the retrig\par
should happen.  If x is 1 say, then it should retrig the note SPEED number of\par
times in one note.\par
ie.  \par
  tick MOD 1 = 0 always, so you would be retrigging every note.\par
  tick MOD 2 = 0 on even numbers, 1 on odd numbers, so you would be retrigging\par
\tab\tab  every other note.\par
etc.\par
When it does happen just play out the note as you would normally.  The note is\par
played on tick 0 as it would normally be.\par
\par
+--------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.26 Effect EAx (Fine VolSlide Up) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+--------------------------------------------+\par
This effect slides the volume up x values per row.\par
\par
EG:\par
C-2 01 C00 (I want to start at note at volume 0)\par
--- 00 EA1 (Now I want to slide the volume up for the channel by 1 unit)\par
--- 00 EA1 (keep sliding up by 1 unit...)\par
\par
Range: x= amount to slide up by. (0h-Fh)\par
\par
This effect is only processed once per row, on tick 0, and it is as simple\par
as just adding x to the current channel's volume. \par
It is only processed on tick 0, and is not touched at all in the other ticks.\par
The only checking to be done is for volumes larger than 64.\par
hint: for all these volume commands, only do the checking for bounds once,\par
just before you actually set the volume.\par
\par
+----------------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.27 Effect EBx (Fine VolSlide Down) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+----------------------------------------------+\par
This effect slides the volume up x values per row.\par
\par
EG:\par
C-2 01 EB1 (I want to slide the volume down for the channel by 1 unit)\par
--- 00 EB1 (keep sliding down by 1 unit...)\par
--- 00 EB1 (keep sliding down by 1 unit...)\par
\par
Range: x= amount to slide up by. (0h-Fh)\par
\par
This effect is only processed once per row, on tick 0, and it is as simple\par
as just subtracting x from the current channel's volume. \par
It is only processed on tick 0, and is not touched at all in the other ticks.\par
The only checking to be done is for volumes smaller than 0.\par
hint: for all these volume commands, only do the checking for bounds once,\par
just before you actually set the volume.\par
\par
+------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.28 Effect ECx (Cut Note) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]\par
+------------------------------------+\par
This effect cuts the volume of the note to 0 after x amount of ticks.\par
\par
EG: (at speed 6 say)\par
C-2 01 EC3 (I want to stop the note at tick 3, or half way between 2 notes)\par
\par
Range: x= number of ticks to wait before zeroing samples volume. (0h-Fh)\par
\par
This effect is ignored on tick 0, but on tick x when you are updating tick\par
based effects, then just set the volume of the channel to 0.\par
Of course if the user specified x as a number more than the speed of the song,\par
then it would be ok because it would never get to tick x, and the effect is\par
ignored.\par
\par
+--------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.29 Effect EDx (Delay Note) \'a6\'a6\'a6 \'a6 UPDATED: T0 [N] : INBETWEEN [Y]\par
+--------------------------------------+\par
This effect waits for x amount of ticks before it actually plays the sample.\par
\par
EG: (at speed 6 say)\par
C-2 01 ED4 (I want to delay playing this note for another 4 ticks)\par
\par
Range: x= number of ticks to wait before playing sample. (0h-Fh)\par
\par
This effect is ignored on tick 0, AND you must make sure you don't play the\par
sample on tick 0.\par
When you arrive at tick x then just play the sample as you would normally.\par
Again if the user specified x as a number more than the speed of the song,\par
then it would be ok because it would never get to tick x, and the effect is\par
ignored.\par
\par
+-----------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.30 Effect EEx (Pattern Delay) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+-----------------------------------------+\par
This effect delays the pattern for the time it would take to play x number of\par
notes.\par
\par
EG:\par
C-2 01 EE8 (I want to play the c-2 note then wait for 8 notes before..\par
C-2 01 000  ... playing the next note)\par
\par
Range: x= number of notes to delay pattern for. (0h-Fh)\par
\par
To implement this effect you are going to have to modify your main interrupt\par
handler (see section 3.3): \par
\par
You are going to have to keep a counter that is subtracted every time your\par
SPEED number of ticks is up, but don't play the note.  You must still keep\par
playing the effects though.\par
\par
It would look something like this.\par
if (tick >= speed) \{\par
\tab ... blah blah blah etc...\par
\tab if (patdelay == 0) \{\par
\tab\tab increment row.\par
\tab\tab playnote.\par
\tab\}\par
\tab else patdelay --;\par
\}\par
else doeffects\par
\par
This just boils down to not playing the note or incrementing the row for x\par
number of notes, until the pattern delay counter is 0.  When it is 0 the mod\par
should keep playing as if nothing had happened.\par
\par
+---------------------------------------+\par
\'a6 \'a6\'a6\'a6 5.31 Effect EFx (Invert Loop) \'a6\'a6\'a6 \'a6 UPDATED: T0 [Y] : INBETWEEN [N]\par
+---------------------------------------+\par
This effect inverts a sample loop or plays it backwards.\par
\par
EG:\par
C-2 01 EF4 (I want to play the loop in this sample backwards at speed 4)\par
\par
Range: x = speed to set invert loop at (0h-0Fh)\par
\par
This effect is not supported in any player or tracker.  Don't bother with it.\par
\par
\par
+----------------------------------------------------------------------------+\par
\'a6                   \'a6\'a6\'a6          : SECTION 6 :          \'a6\'a6\'a6                  \'a6\par
\'a6                   \'a6\'a6\'a6 Protracker 1.1B Format Document \'a6\'a6\'a6                  \'a6\par
+----------------------------------------------------------------------------+\par
\par
Offset  Bytes  Description\par
   0     20    Songname. Remember to put trailing null bytes at the end...\par
 \par
Information for sample 1-31:\par
 \par
Offset  Bytes  Description\par
  20     22    Samplename for sample 1. Pad with null bytes.\par
  42      2    Samplelength for sample 1. Stored as number of words.\par
\tab        Multiply by two to get real sample length in bytes.\par
  44      1    Lower four bits are the finetune value, stored as a signed\par
\tab        four bit number. The upper four bits are not used, and\par
\tab        should be set to zero.\par
\tab        Value:  Finetune:\par
\tab\tab  0        0\par
\tab\tab  1       +1\par
\tab\tab  2       +2\par
\tab\tab  3       +3\par
\tab\tab  4       +4\par
\tab\tab  5       +5\par
\tab\tab  6       +6\par
\tab\tab  7       +7\par
\tab\tab  8       -8\par
\tab\tab  9       -7\par
\tab\tab  A       -6\par
\tab\tab  B       -5\par
\tab\tab  C       -4\par
\tab\tab  D       -3\par
\tab\tab  E       -2\par
\tab\tab  F       -1\par
 \par
  45      1    Volume for sample 1. Range is $00-$40, or 0-64 decimal.\par
  46      2    Repeat point for sample 1. Stored as number of words offset\par
\tab        from start of sample. Multiply by two to get offset in bytes.\par
  48      2    Repeat Length for sample 1. Stored as number of words in\par
\tab        loop. Multiply by two to get replen in bytes.\par
 \par
Information for the next 30 samples starts here.  It's just like the info for\par
sample 1.\par
 \par
Offset  Bytes  Description\par
  50     30    Sample 2...\par
  80     30    Sample 3...\par
   .\par
   .\par
   .\par
 890     30    Sample 30...\par
 920     30    Sample 31...\par
\par
Offset  Bytes  Description\par
 950      1    Songlength. Range is 1-128.\par
 951      1    Well... this little byte here is set to 127, so that old\par
\tab        trackers will search through all patterns when loading.\par
\tab        Noisetracker uses this byte for restart, but we don't.\par
 952    128    Song positions 0-127. Each hold a number from 0-63 that\par
\tab        tells the tracker what pattern to play at that position.\par
1080      4    The four letters "M.K." - This is something Mahoney & Kaktus\par
\tab        inserted when they increased the number of samples from\par
\tab        15 to 31. If it's not there, the module/song uses 15 samples\par
\tab        or the text has been removed to make the module harder to\par
\tab        rip. Startrekker puts "FLT4" or "FLT8" there instead.\par
\par
Offset  Bytes  Description\par
1084    1024   Data for pattern 00.\par
   .\par
   .\par
   .\par
xxxx  Number of patterns stored is equal to the highest patternnumber\par
      in the song position table (at offset 952-1079).\par
\par
Each note is stored as 4 bytes, and all four notes at each position in\par
the pattern are stored after each other.\par
\par
00 -  chan1  chan2  chan3  chan4\par
01 -  chan1  chan2  chan3  chan4\par
02 -  chan1  chan2  chan3  chan4\par
etc.\par
\par
Info for each note:\par
\par
 _____byte 1_____   byte2_    _____byte 3_____   byte4_\par
/                 /        /                 /\par
0000          0000-00000000  0000          0000-00000000\par
\par
Upper four    12 bits for    Lower four    Effect command.\par
bits of sam-  note period.   bits of sam-\par
ple number.                  ple number.\par
\par
Periodtable for Tuning 0, Normal\par
  C-1 to B-1 : 856,808,762,720,678,640,604,570,538,508,480,453\par
  C-2 to B-2 : 428,404,381,360,339,320,302,285,269,254,240,226\par
  C-3 to B-3 : 214,202,190,180,170,160,151,143,135,127,120,113\par
\par
To determine what note to show, scan through the table until you find\par
the same period as the one stored in byte 1-2. Use the index to look\par
up in a notenames table.\par
\par
\par
}
 